\documentclass[a4paper,10pt]{article}
\usepackage[english]{babel}
\usepackage{thesis}
%\usepackage{a4wide}
% Small enumerate and itemize
\usepackage{mdwlist}

% Fill in the header:
\lhead{Combining Robocup Rescue and XABSL}
\rhead{Maarten de Waard}

\begin{document}

\input{title.tex}
\thispagestyle{empty}
\tableofcontents
\setcounter{page}{0}
\newpage

\begin{abstract}
In this research, a product will be introduced, that combines the Extensible
Agent Behavior Specification Language (XABSL) with any program, capable of
having a socket connection. A use of this product is shown, by combining it to
the rescue project on the University of Amsterdam, using
\textit{UsarCommander},
a program designed to control one or more robots, in a virtual rescue operation.
\end{abstract}
%\begin{multicols}{2}
\section{Introduction}
The research will be focussing on combining the \textit{Extensible Agent
Behavior Specification Language} (XABSL) with any program capable of making a
socket connection. In particular, the focus will lay on virtual rescue
operations, otherwise known as the \textit{RoboCup Rescue League}. Using a
behavior specification language will make it possible to separate specification
of behaviors from implementation.

Currently, the focus of research in the rescue missions is mainly on creating
smart implementations of sensors. Much of the actual controlling of robots is
done by hand, using programs that forward the camera images of the robots to a
human operator controlling them. Some of these operators use simple behaviors to
help them, like for example making the robot automatically traverse a path to a
specified point. This kind of simple task can be called a behavior.

An improvement that can be made in these behavior controlled robots, is in 
the specification of which behavior should be selected in a certain situation
and how the behavior is executed. This can be done by creating
behavior-controlled robots, that can autonomously select the best behavior to
activate on a certain moment, and using their sensors as input, can choose the
right way to navigate.

This research will make use of XABSL, a behavior specification language, which
makes it possible to separate the specification of a behavior, from the implementation.

%Results in the RoboCup Rescue missions are counted by how many victims
%are found on the map, so improvement can be shown by finding more victims using
%the results of this research.
%

Currently, not many behavior-controlled exploration algorithms exist.
An exception is path finding on challenging terrain
\cite{seraji2002behavior} . This research will result in a method to
easily adjust and improve the behavior of any robot in any robot commanding
program, especially focussing on UsarCommander, the program used by the UvA Rescue
team\footnote{Team description and more at: \url{http://www.jointrescueforces.eu/wiki/tiki-index.php}}.

There has however been research in Behavior Based Artificial Intelligence since
1986.

\section{Behavior Based Artificial Intelligence}
This was first researched by brooks \cite{brooks1986robust}, who laid the
foundations of looking at intelligence in different layers. Brooks proposed that
the following four elements were key requirements in a robot controlling system:
\begin{enumerate}
    \item \dik{Multiple goals:} A robot should be able to chase multiple goals at the
    same time, for example reaching a place in minimal time, while conserving
    power reserves. There should be an ability to prioritize goals, so that
    dangerous situations can be evaded while the main goals are still executed
    when the robot is able to. A simple example is being able to evade obstacles
    while reaching the place it wants to reach.
    \item \dik{Multiple sensors:} Most robots have more than one sensor, each
    having its own error measure. Some sensors have a bigger error in certain
    situations then others. For example while traversing inside a building, a
    robot should not be trusting its GPS sensor (Global Positioning Satelite),
    while being outside this would be a good option. A robot should be able to
    cope with these different errors, and use the right sensors at the right
    time with the right amount of trust.
    \item \dik{Robustness:} A robot's artificial intelligence should be
    robust. This means that when certain sensors fail, or unexpected
    deviations from it's normal environment occur (for example when a robot
    meant for
    inside-use comes outside a building, where there are less walls, but more
    small obstacles), the robot should still be able to act in a sensible way,
    in stead of just stop and stay still, or act randomly.
    \item \dik{Extensibility:} Brooks only speaks of being able to enlarge
    the processing power of the robot, when more sensors are loaded on the
    robot. I would like to add to this, that the intelligent system should have
    some kind of modularity in its software, making extending the system to work with a new kind
    of sensor, or even a totally different robot or environment (for example
    virtual vs the real world) easy, without having to rewrite big parts of
    code, or search through the program to find where a sensor should be added
    and where the activation of the sensor occurs, etc.
\end{enumerate}

Brooks explains that typically, robot intelligences slice problems up in the
following order: Sense, map sensor data in a world representation, plan, execute
task and at last: control motors to do so. He then offers a new implementation
of problem-decomposing, in the following order, and calls these `Levels of
competence'

\begin{enumerate*}
\setcounter{enumi}{-1}
\item ``Avoid contact with objects (whether the objects move or
are stationary).''
\item ``Wander aimlessly around without hitting things.''
\item ```Explore' the world by seeing places in the distance
that look reachable and heading for them.''
\item ``Build a map of the environment and plan routes from one
place to another.''
\item ``Notice changes in the `static' environment.''
\item ``Reason about the world in terms of identifiable objects
and perform tasks related to certain objects.''
\item ``Formulate and execute plans that involve changing the
state of the world in some desirable way.''
\item ``Reason about the behavior of objects in the world and
modify plans accordingly.''
\end{enumerate*}

\begin{figure}
    \centering
    \includegraphics[width=.8\textwidth]{images/level0.png}
    \caption{A level 0 control system, as proposed by Brooks}
    \label{fig:levelzero}
\end{figure}
\begin{figure}
    \centering
    \includegraphics[width=.8\textwidth]{images/level2.png}
    \caption{A level 2 control system, as proposed by Brooks}
    \label{fig:leveltwo}
\end{figure}

Each level of competence adds complexity to the entire system, thereby creating
a layered implementation of behavior in an (in that time) untraditional way.
Brooks proposes that each of these layers can be implemented in a finite state
automaton, resulting in figure \ref{fig:levelzero} as a representation for the
zeroth level, and, by augmenting this with an FSA for level one and two, in
figure \ref{fig:leveltwo}.

In the level 0 representation, the robot will `run away' when it is standing
still and a moving object closes in. Alternatively, it will halt when a probable
collision is detected. This is enough for simple obstacle avoidance.

This representation is augmented by inserting the avoidance and wander states
above it parallel to the runaway state, in figure \ref{fig:leveltwo},
This results in level 1 behavior: a robot capable of
wandering around aimlessly, without hitting any objects. The direction outputted
by the level 0 FSA is, when possible, overridden by the direction of the level 1
output. 

As can be seen, this method a very large FSA, when we add the second level of
control. This has the advantage of being capable of more complex behavior, in
this case exploring an area, thus no more simply wandering around, but reaching
places it has not yet explored. A disadvantage of this method, however, is that
these big FSA's are quite complex to understand Adding more and more complexity
to the system results in bigger and bigger images, resulting in more
representation complexity and, in the worst case, in a system that only the
creator can understand fully, but cannot anymore be represented in a clear way.
Of course it needs to be considered that this system was created in 1986, when
computers were many times slower and capabilities were limited. Brooks managed
to get the level 2 version working on a real robot in the time, by distributing
the system over many cores.

This is the main advantage Brooks proposes, of this kind of implementation: The
processes needed for the in- and output of the states, can be done with the
least possible interaction between processes, making Brooks able to distribute
the implementation over different processors and thereby able to run this, for
that time, complex program.

Nowadays, this implementation is a bit outdated, mainly because of the complex
structure of the representation. The behavior based approach, however, has been
used in several solutions to controlling robots. These solutions will be
discussed in the following section.

\section{BBAI Implementations and Alternatives}
This section will cover most of the BBAI implementations that can be chosen from
when deciding to create an application that should be capable of specifying a
Behavior Based artificial intelligence. 

\subsection{XABSL}
One of the implementations of behavior based software is
\textit{XABSL}\cite{loetzsch2004xabsl}\cite{lotzsch2004designing}: a
 programming language, created to easily describe behaviors for autonomous agents
based on hierarchical finite state machines. It is the
software that has been used by the German robotic soccer team to specify their
robots' behaviors. The team won in 2008, and the years after that.

The language is used to specify a finite state automaton hierarchy. This means
that the user defines several finite state automata, which can activate each
other. Each state makes decisions on certain variables, and as an output
activate another state or another FSA. The hierarchies are built up from the
following components:

\begin{figure}
    \centering
        \includegraphics[height=5cm]{../files/option_drive_circle.png}
        \includegraphics[height=5cm]{images/POSH-smaller.png}
    \caption[XABSL hierarchy and POSH hierarchy]{Left: An example of a figure generated by the XABSL compiler, from
    XABSL code. Right: a POSH hierarchy}
    \label{fig:simpleFsm}
\end{figure}
A XABSL-specification is built up from the following components:

\begin{itemize}
\item \dik{Agents:} A rooted acyclic graph, containing all the behaviors for one
agent. Several of these agents can be created, all having their own graph and
thus their own behavior.
\item \dik{Options:} Complex agent behavior. Each option is on itself a finite
state machine, containing several states. When creating an agent, the start
option can be specified, which makes the user able to create different agents
from one Option hierarchy. Options can also have parameters, enabling an option
to have different outputs for different agents. Figure \ref{fig:simpleFsm}
contains an example of a simple option, that makes the agent turn 360 degrees
and then stop and wait for a certain amount of time.
\item \dik{States:} Options are bounded to each other by states, each state has
a decision tree, and an action. The decision tree decides whether to stay at
this state, or to go to another state. These decisions are based on variables
that can either be internal, or inputs.

When a decision tree decides to stay at its current state, an action is
performed. Actions can be activation of a basic behavior, or of another option.
Several actions per state are permitted.
\item \dik{Basic behavior:} At every leaf of an option (so, every state with no
other states to reference to) a basic behavior is activated. This is a small
piece of native code (C++ or Java), that influences the actions of the agent
in its world. 
\end{itemize}

This is an improvement over Brooks' BBAI, because the FSA's are now no
longer directly connected to each other through state connections, but are
connected via the actions of
certain states, in that way improving the comprehensibility of the
representation, thereby also improving the modularity of the system, because
modules can be better recognized and then expanded.

By using basic behaviors, that can be written in C++ or Java, XABSL also
enables distribution of the system: Each basic behavior can run its own module.
This way basic behavior can be a module that simply makes a robot move, but also a
module that finds a ball in a soccer field, using libraries like OpenCV. This
makes an XABSL application capable of the same things as any native C++ or Java
application, which is almost everything one or more computers can do.

Section \ref{sec:xabsl-focus} will explain more clearly the advantages of XABSL,
and the possibilities of agents, options, states and basic behaviors.

\subsection{POSH}
POSH \cite{brom2006posh} is a very similar alternative implementation of a Behavior Specification
Language. Posh is defined as a \textit{Behavior Oriented Design}, which is
a combination of \textit{Object Oriented Design} (OOD, used by object oriented
programming languages like Java and C++) and \textit{Behavior Based Artificial
Intelligence} (BBAI). 

From OOD the language takes the object hierarchy that it is known for. In object
oriented languages a person is capable of creating an object based on another
object. These can be \textit{Abstract classes}, or \textit{Interface classes}. When using an
abstract class to define an object, this means the class can be extended by
another object: The new object automatically has all the properties its
\textit{Base class} (the original, abstract, class) has, but can override some
of them, or add new ones. An interface class can define what its subclass should
have, for example when an interface class specifies a method that searches for a
doorway, using laser sensors, its subclass should implement this method. The
interface class itself does not have any actual implementations. BOD objects are literally built in an object oriented language, thereby having
all its advantages

The BBAI-part of it is the decomposition of intelligence
as subtasks called \textit{acts}. Examples of acts are knowing your position and
planning a route. There is no implementation of prioritizing certain acts above
others, other than that they come earlier in the POSH diagram. 

Behaviors in BOD are thus specified as a \textit{Behavior object}, written in an
Object Oriented language. They are split up in actuators and senses. The
actuators are used to act on the world, for example move in a certain direction,
or pick something up, whereas the senses are used to inform the planner the
current context. Context can be any piece of information about the world, or the
agents internal state. The
whereabouts of an object, or the data from a laser scanner can be context, but
the agents current battery level is also context.. All the specified behaviors together form the
\textit{Behavior Library}, which can be used by the action planning system to
select the right behavior on the right time. 

Furthermore POSH uses three aggregates: simple sequences, competences and drive
collections.

\begin{enumerate}
    \item \dik{Simple sequences:}
        The sequence is simply a sequence in which order a diagram should be
        traversed
    \item \dik{Competences:}
        A competence is a prioritised set of condition-action pairs. These
        condition-action pairs are based on the current context (described
        above). Because of the hierarchical structure of the system, only small
        pieces of context have to be processed at a time. When a certain part of
        competence is reached, competences have been passed higher up in the
        hierarchy, meaning that this information needs no more checking. In this
        part there is assumed that in the time it took to traverse the tree, the
        world has not changed significantly.
    \item \dik{Drive Collections:}
        The drive collection is a special competence, that is executed before
        each program cycle. The collection contains all vital condition-action
        pairs to be able to survive. For example when an enemy is close (given
        that the environment has enemies that can seriously harm the agent), the
        agent should hide from the enemy, or take other actions not to get
        harmed. The drive collection can also contain routines that have to be
        executed every once in a while, like checking the environment for safety
\end{enumerate}

This is actually quite similar to XABSL,
because selects actions based on decisions based on its findings. 
The actions are always executed by an external program. There are some important differences though:

\begin{itemize}
    \item POSH is designed to be used by non-pro\-gram\-mers. This means the
    interface is easy, colorful and simple, whereas XABSL prioritizes complex
    capabilities, ignoring the fact that non-programmers then couldn't use it.
    This improves the adaptability of XABSL far above the capabilities of POSH,
    resulting in ability to create more complex behaviors.
    \item Where XABSL has a close coupling with the perception stream of the
    robot, POSH has no variable management, enabling the system to be a lot
    easier to use, but also maximizing the complexity of the specified behaviors
    to a lower maximum than XABSL offers.
\end{itemize}

\subsection{Petri Net Plans}
% First describe petri nets
Another possible method to represent robot behavior as plans, is by using
\textit{Petri Net Plans} (PNP), a language based on \textit{Petri Nets} (Also known as
Place/Transition Nets or P/T Nets).

A Petri net is a mathematical modelling language, making it an alternative to
the use of Finite State Automata. The formal definition of a \textit{net}, as given
in \cite{esparza1994decidability}, is the following:

``A \textit{net} N is a triple $(S, T, F)$, where $S$ and $T$ are two disjoint,
finite sets, and $F$ is a relation on $S \cup T$ such that $F \cap (S \times S)
= F \cap (T \times T) = \emptyset$.''

In this definition, the elements of $S$ and $T$ are respectively called
\textit{places} and \textit{transitions}. The elements of $F$ are called
\textit{arcs}. A transition $t$ can be made, when a marking $M$ marks all of its
input places. If $t$ is enabled at $M$, it will occur, and thus lead to the
successor of marking $M$, which we call $M'$. This is denoted by $ M
\stackrel{t}{\longrightarrow} M'$. 

A \textit{Petri Net} is a pair $(N, M_0)$, with N representing a net, and
$M\_0$ representing the \textit{initial} marking of $N$, which means that $M_0$
is the first marking of $N$. A sequence of transitions that enables the graph to
go from marking $M_0$ to $M_n$, is called a \textit{finite occurrence
sequence}.  Infinite occurrence sequences are possible too, when there is no
clear end marking, but transitions keep on happening. If a state is reached
where transitions can no longer occur, this is not called an infinite occurrence
sequence. 

The main advantage of Petri Nets, is that due to their definition, they are very
analyzable. Three attributes exist, on which analysis can be done more easily
than most comparable mathematical models.
\begin{enumerate}
    \item \dik{Reachability:}
    For most graphs it is hard to exactly calculate if every node in the graph
    can possibly be reached. For petri nets, it is possible to calculate this
    automatically, and with great certainty. An algorithm for this calculation
    is given in \cite{mayr1981algorithm}.
    \item \dik{Liveness:}
    Degrees of liveness can be assigned to Petri Nets. Loosely speaking, a petri
    net is live when every transition can always occur again. More precisely,
    the following \textit{levels} of liveness are possible\footnote{From
    wikipedia}:
    \begin{itemize}
        \item $dead$: It can never fire, i.e. it is not in any firing sequence
        in $L(N, M_0)$
        \item $L_1 -live$: (potentially fireable) if and only if it may fire, i.e. it is in
        some firing sequences in $L(N, M_0)$.
        \item $L_{2}-live$: if and only if it can fire arbitrarily often, i.e. if for every
        positive integer $k$, it occurs at least $k$ times in some firing
        sequence in $L(N, M_0)$.
        \item $L_{3}-live$: if and only if it can fire infinitely often, i.e. if for every
        positive integer $k$, it occurs at least $k$ times in $V$, for some
        prefix-closed set of firing sequences $V \subseteq L(N, M_0)$
        \item $L_4 -live$ (live) if and only if it may always fire, i.e. it is $L_1$-live
        in every reachable marking in $R(N, M_0)$.
    \end{itemize}
    \item \dik{Boundedness:}
    A petri net is \textit{bounded} if its set of reachable markings is finite.
    For petri nets, it has been shown that this is also decidable, because an
    unbounded Petri net, is easily characterized in the following matter:

    An unbounded petri net is characterized by a reachable marking $M$, and a
    sequence of transitions $\sigma$, so that $M \stackrel{t}{\longrightarrow} M
    + L$, where L is some non-zero marking and the sum of these markings is
    defined place-wise. The sequence $\sigma$ can be called a \textit{token
    generator} when it, starting at $M$ leads to $M + L$. This generator makes
    the petri net unbounded.
\end{enumerate}

For this section, it is extra important to know that Petri Nets have the ability
of forking and joining their tokens. This means that from one state, two tokens
can be output, going to two different states. On the other hand two tokens from
different states can be asked as input for one state, making the state wait for
output from both input transitions, before continuing by outputting one token of
itself, in the next marking.

Petri net plans \cite{ziparo2011petri}, is a language using these petri nets, to
create special \textit{plans}. Because of the petri nets fork and join
abilities, Petri Net Plans is explicitly suitable for controlling several
robots.  The clear advantage of this approach, is that there is only one
petri net plan needed, to control all the robots in the field, whereas most
other methods have one plan per agent. 

\begin{figure}
    \centering
    \includegraphics[width=.8\textwidth]{images/petriNet.png}
    \caption{A petri net describing the actions of two robots, for a simple task
    execution. The robots use h\_sync to synchronize. Due to the join
    capabilities of a petri net, none of the robots will continue to state
    $p_{0n}$ before the sync is done.}
    \label{fig:petri}
\end{figure}

An example of a petri net plan can be seen in figure \ref{fig:petri}. It can be
seen that the h\_sync method is used to halt the robots until both have synced,
and only then continue to the next state.

Other advantages of Petri Net Plans are closely related to the advantages of
Petri Nets above Finite State Automata. A consideration has be done though: It
is harder to specify a completely sufficient petri net plan, than to specify
several simple Finite State Automata.

\subsection{COLBERT}
COLBERT is a programming language using the Saphira Architecture. 
The abstract of \cite{konolige1997colbert} states that: 
``The design criteria for Colbert are:''
\begin{enumerate*}
\item ``To have a simple language with standard iterative, sequential and
conditional constructs.''
\item ``To have a clear and understandable semantics based on FSAs.''
\item ``To have a debugging environment in which the user can check the state of
the system and redefine Colbert activities.''
\item ``To have an small, fast, and portable executive.''
\end{enumerate*}

The main advantage of COLBERT is that it is small and fast. And as we all know:
quick reflexes are important in a dangerous world, so having small and fast
behavior based AI has it advantages. COLBERT is based on a subset of ANSI C and
it is even possible to compile it to native C code, to make the program even
easier to run.

\begin{figure}
\centering
\begin{lstlisting}
act patrol2{int a}
    start: 
        while(a != 0)
        {
            a = a-1;
            Turnto(180);
            Move(1000);
            Turnto(0);
            Move(1000);
        }
        succeed;
    onInterrupt:
        waitfor(sfDonePosition());
        suspend;
    onResume:
        a = a+1;
        goto start;
\end{lstlisting}
    \caption{A simple specification of a patrolling behavior in COLBERT}
    \label{fig:colbert}
\end{figure}

Figure \ref{fig:colbert} shows a small sample of specification in the COLBERT
language. 

These are the main alternatives. There are others, like using constraint logic,
with aid of If-then-else statements directly in the main program. One can also
use machine learning techniques, for example \textit{Reincorcement Learning}
methods are used by \textit{Sarsa} and \textit{Q-learning}. This is, however a
complete different way of looking at the problem, with its own set of results,
which are not comparable to the ones reachable with human-specified behaviors,
because the current learning techniques are not yet sufficient.

\section{Language of choice}
\label{sec:xabsl-focus}
In this research, of the above specified languages, XABSL has been chosen. There
are a few advantages of XABSL above the others, but also a few disadvantages.
The following part will discuss why XABSL is, in this case, a better choice than
de aforementioned alternatives. Then, this section will explain more about how
XABSL hierarchies are specified, and how they are combined with other programs,
traditionally.

\subsection{Advantages of Using XABSL}
The first thing that needs to be considered when choosing a behavior
specification type and language, is what characteristics are the most
important. Here is a list of things that the ideal behavior specification
language for multiple robot control should have.
\begin{itemize}
    \item The points mentioned by Brooks:
    \begin{itemize}
        \item \textit{Multiple goals}
        \item \textit{Multiple sensors}
        \item \textit{Robustness}
        \item \textit{Extensibility}
    \end{itemize}
    \item \dik{Modularity:} It should be possible to build up a specification
    in small pieces, thereby keeping track of what is specified where, and not
    getting entangled in pages of code, of which no body remembers the function
    \item \dik{Documentation:} Most programs, especially the ones used in the
    RoboCup, are not only used by one person. For a team to be able to work on a
    project together, it is good to easily understand the work somebody else has
    done. This is achieved by keeping documentation in your code, but it is
    achieved even more by documentations on websites or in other documents, that can be consulted
    without having to actually dig into the code.
\end{itemize}

All of the mentioned possibilities enable having \dik{multiple
goals}. POSH has the possibility of adding the set of extra important goals,
which the others do not, but POSH has too many disadvantages in relation to
XABSL to make this point count.

Of all the possibilities discussed, XABSL has the
clearest solution for dealing with \dik{Multiple sensors}. XABSL has input variables,
which, together, are a world representation that is constantly updated by the
Engine, that runs the decision-making program. Petri Net Plans has of course the
added possibility of keeping track of several robots at the same time, in the
same graph. This could be seen as an advantage above XABSL, but since XABSL
offers us the possibility of adding extra variables from the running program,
the relevant information about other robots could also be added to the reasoning
engine via that method.

\dik{Robustness} is the ability of functioning in another setting than usual. A
lot of the robustness of a robots behavior is not in the language in which it is
specified, but mainly in the specification itself. A way to force programs to be
at least a bit robust, is by error-checking the specified behaviors before
running the program. This can be done very easily in PNP, because Petri Nets
have so many algorithms for complete checking of reachability, liveness and
boundedness. XABSL however also offers a compiler that compiles your code and
finds the necessary problems. A complete survey of if every node in the graph is
reachable is not done, but to be able to do that, more knowledge of the input
variables should be present. 

\dik{Extensibility} was a bigger problem in 1986 then now. Computer systems were
slower, forcing programmers to create the fastest possible programs, when
creating something heavy, like a behavior control system. Brooks' system had
problems with their \textit{level 2} specification, whereas nowadays the cheaper
computers could run that. Inherently, almost all possible options of creating a
behavior specification would allow for a system to be expanded with a new
sensor, or a new kind of processor. In XABSL, adding a new sensor, would simply
mean adding a new option, that accounts for dealing with that sensor. Another
possibility would be to process the sensor to a world representation, in
whatever program is used in combination with XABSL. 

XABSL, together with POSH, are the most \dik{modular} languages of the ones
proposed. This is because of the modular way the behavior specifications are
built up. My preference goes to XABSL in this case, because its finite state
automata enable a bit more complex implementations than the acts used in POSH
hierarchies. 

In contrast to the other possibilities, the XABSL compiler offers a method of
directly translating the code to svg images, and the comments to html context,
and automatically combining those to a full web page, with the entire
documentation. Figure \ref{fig:simpleFsm} shows an example of an automatically generated image.
These images, together with the extracted comments, make for a complete
documentation, which provides overview to any one who's interested, in less time
and effort than when some body would have to look through the code.

\subsection{Disadvantages of Using XABSL}
Especially PNP offers some great possibilities that XABSL does not. Using Petri
nets in stead of the FSA-hierarchy XABSL provides, has the following advantages:
\begin{itemize*}
    \item Mathematical proof of reachability: It can be useful to be able to
    show that every node in a behavior specification can certainly be reached.
    Unreachable nodes mean bad specification, which mostly comes from, or
    results in bugs, which in their turn results in a program that could have
    worked better. Some of these differences, however, are resolved in
    \cite{alur1998model}
    \item Multiple robots in one plan: PNP offers a possibility of using one
    plan with multiple robots, at the same time. Of course, when using XABSL two
    robots can use the same option tree, but when using PNP, the robots actually
    share the Petri Net Plan, enabling the system to work more efficiently. A
    part of this problem is solved by creating a shared world-representation in
    the program that is used in coherence with XABSL, but some functions, like
    for example the h\_sync in figure \ref{fig:petri}, are difficult, if not
    impossible, to recreate using XABSL.
\end{itemize*}

\subsection{Creating an XABSL-specification}
When using XABSL in coherence with any application, the \textit{XABSL engine} is
used to control the behavior. This engine uses a user specified XABSL graph and
the internal variables of the program it is running in in coherence, to make
decisions about what \textit{basic behavior}, or \textit{option} to run next.
More about the engine can be read in section \ref{sec:xabsl-engine}

This engine runs on \textit{intermediate code} that is automatically generated
from several XABSL files, by the XABSL compiler. This intermediate code is a
sort of 


\subsection{ Traditionally Combining XABSL With Any Existing Program}
\label{sec:xabsl-engine}




\section{RoboCup Rescue}
\subsection{Description}
The project used in cooperation with the application, is UsarCommander.
UsarCommander\footnote{Available at
\url{http://www.jointrescueforces.eu/wiki/tiki-index.php}}, originally developed by Bayu Slamet, and extended by Arnoud
Visser and many others. This program takes care of connecting to USARSim (the
simulator used in the Robocup) and
makes the user able to easily get sensor data from the robots in it. It is also
possible to control the robots with several types of behavior, like
corridor-following, obstacle-avoidance, or tele-operation. The last of which
enables the operator to manually control the robots by hand, using an
interactive human interface.

Over time, the system has been expanded with many subprojects, for example one
implementing a SLAM
(Simultaneous Localisation And Mapping) algorithm, to make an accurate map from
the sensor data of several robots\cite{slamet2006manifoldslam}. All the information used and produced by
these subprojects can be accessed by other subprojects, resulting in an ideal
environment for creating new robot-controlling applications.

\subsection{Motivation to use it}
The main reason to use this program, instead of any other, to interface my
software with USARSim is that it has so many features. The presence of many
subprojects in the code, makes it possible to make a very efficient autonomous
exploration algorithm interfacing with the subprojects at hand. Without using UsarCommander all
the needed software should be taken from somewhere else, or implemented solely
for this purpose.

Other software for this purpose is available too. %TODO: Specify other programs

but since this is a bachelor
thesis on the University of Amsterdam, and this is the software used by it in
the RoboCup, this is the logical choice.
\section{Approach}
\begin{comment}
This section will contain my approach
\end{comment}

\subsection{Interfacing both programs}
Since the UsarCommander is written in Visual Basic, and the basic behaviors of
XABSL are written in C++, a bridge should be made. This is done by creating a
Dynamic Link Library (DLL). This DLL contains the needed functions of the C++
program, making them accessible for Visual Basic. The bridge works both ways, so
Visual Basic can offer output symbols to the XABSL Engine, while the engine can
offer input symbols to the agent.

\subsection{Creating a succesful hierarchy}
This section will tell about the FSM hierarchy I will make for autonomous
exploration


\section{Results}
This section will contain results, hopefully in the form of explored maps, numbers of victims found, etc.

\section{Conclusion}

%\end{multicols}{2}
\bibliography{bib}{}
\bibliographystyle{plain}
\end{document}

